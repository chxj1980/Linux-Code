### 读写锁，互斥锁的缺点
#### 阻塞线程
#### 不是什么时间都

## 1.条件变量是锁吗？
不是锁，但是条件变量能够阻塞线程
使用条件变量+互斥锁
  互斥锁：保护一块共享数据
  条件变量：引起阻塞
  生产者和消费者模型
## 2.条件变量的两个动作？
  条件不满足，阻塞线程
  当条件满足时，通知阻塞的线程开始工作    信号 ——》通知一个  广播-》通知所有
## 3.条件变量的类型：pthread_cond_t;

## 4.主要函数
1.初始化条件变量
pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);

2.销毁一个条件变量
int pthread_cond_destroy(pthread_cond_t *cond);

3.限时等待
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
           pthread_mutex_t *restrict mutex,
           const struct timespec *restrict abstime);

4.阻塞等待一个条件变量
int pthread_cond_wait(pthread_cond_t *restrict cond,
           pthread_mutex_t *restrict mutex);
  阻塞线程
  将已经上锁的Mutex解锁
  解除阻塞后，对互斥锁进行加锁

5.唤醒至少一个阻塞在条件变量上的线程
int pthread_cond_signal(pthread_cond_t *cond);

6.唤醒全部阻塞在条件变量上的线程
int pthread_cond_broadcast(pthread_cond_t *cond);

## 5.练习
使用条件变量实现生产者-消费者模型



条件变量的作用是用于多线程之间关于共享数据状态变化的通信。当一个动作需要另外一个动作完成时才能进行，即：当一个线程的行为依赖于另外一个线程对共享数据状态的改变时，这时候就可以使用条件变量

假设没有条件变量，对于一个生产者消费者问题，消费线程在得知队列中没有产品时，将阻塞自己。生产线程给队列中放入产品，但是没有办法激活消费线程，而消费线程处于阻塞状态也没有办法自激活。如果消费线程使用忙等的方式，通过不断地查询来判断是否有产品将大量的浪费CPU时间。消费线程可以使用睡眠+查询的方式，即发现队列中没有产品时，sleep一段时间，然后再查询。问题是睡眠多长时间？时间太长，实时性不好，时间太短，还是浪费CPU时间。

所以，通过生产线程通过唤醒消费线程时最好的方式。现在我们考虑一种实现，消费线程在阻塞之前要先解锁，同时还要将自己的标识符放入一个地方，以便生产线程通过这个标识符来激活自己。这样看起来是没问题了，然而不要忘记了，线程之间是并发/并行的。消费线程可能刚完成解锁的操作，就被生产线程获取到了并开始执行，这时，因为消费线程还未挂起自己，来不及将自己的标识符保存在某个位置，所以生产线程不认为有正在等待的线程。这时，切换到消费线程后，消费线程将永远的等待下去，虽然队列中有产品。而生产线程因为队列中有产品可能也一直的等待下去，形成了死锁。

解决方法是必须让解锁、保存线程标识符、挂起这一系列操作成为原子操作。这中解决方案就是条件变量，所以不难想到使用条件变量的时候必须要“伴随”一个互斥量。

条件变量是与互斥量相关联的一种用于多线程之间关于共享数据状态改变的通信机制。它将解锁和挂起封装成为原子操作。等待一个条件变量时，会解开与该条件变量相关的锁，因此，使用条件变量等待的前提之一就是保证互斥量加锁。线程醒来之后，该互斥量会被自动加锁，所以，在完成相关操作之后需要解锁。

条件变量总是和谓语相关，学过《离散数学》应该还记得谓语表达式吧。谓语是具有唯一真假值的句子。程序中，可以用谓语来描述当前线程需要的状态。如果该谓语值为假，需要使用条件变量等待。醒来之后，由于系统的并发性，一般需要再次判断谓语值是否为真，如果不为真，则再次使用条件变量进行等待。

互斥量是用来防止对不变量的破坏，换句话说，是用来规范线程对共享数据的竞争使用。而条件变量是用来对线程同步，即用来协调各个线程合作完成某个任务。比如：足球场上，两个足球队对一个球的使用叫做竞争，可以使用“马赛回旋”这种“互斥量”对球加锁，防止被抢。而传球这个动作就是使用“条件变量”进行唤醒，它的作用是保证一个球队的各个成员能协作起来将球踢进对方的球门。

条件变量的关注对象是共享数据状态的变化，这一变化可以使用谓语来描述。因为涉及到共享数据，所以需要互斥量。互斥量和条件变量的对应关系为1:N.就是说一个互斥量可以对应多个条件变量，一个条件变量只能对应一个互斥量。这个可以这样理解：因为共享数据有很多种状态，描述这些状态就需要多个谓语，所以需要用多个条件变量。

条件变量和谓语的对应关系一般最好为1:1.1：N或者N：1并不是不可以，但是容易引起死锁和竞争问题，要特别注意。若1个条件变量对应于多个谓语时，唤醒应采用广播的方式而不是signal的方式。